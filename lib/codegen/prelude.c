// Auto-generated by maysick compiler

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef int64_t m_int;

enum {
  M_INIT_STRSIZE = 0x100,
};

typedef struct {
  size_t size;
  size_t len;
  union {
    char *     __u8;
    uintptr_t *__n;
  } head;
} m_string;

#define __aligned(n, a) (n & (~a)) + (n & a != 0 ? a : 0)
#define aligned(n, align) (__aligned((n), (align - 1)))

m_string *m_string_with_capacity(size_t size) {
  m_string *str = calloc(1, sizeof(m_string));

  str->len       = 0;
  str->size      = size < M_INIT_STRSIZE ? M_INIT_STRSIZE : aligned(size, 16);
  str->head.__u8 = calloc(sizeof(uintptr_t), str->size >> sizeof(uintptr_t));

  return str;
}

m_string *m_string_new() { return m_string_with_capacity(0); }

m_string *m_string_from_cstr(const char *cstr) {
  size_t    len = strlen(cstr);
  m_string *s   = m_string_with_capacity(len);

  for (size_t i = 0; i < len; i++) {
    s->head.__u8[i] = cstr[i];
  }

  return s;
}

void m_string_free(m_string *str) { free(str->head.__u8); }

void m_string_expand(m_string *str) {
  uintptr_t *head_new =
      calloc(sizeof(uintptr_t), str->size >> (sizeof(uintptr_t) >> 1));

  for (size_t i = 0, s = str->size >> (sizeof(uintptr_t)); i < s; ++i) {
    head_new[i] = str->head.__n[i];
  }

  free(str->head.__u8);

  str->head.__n = head_new;
  str->size     = str->size << 1;
}

void m_string_expand_if_needed(m_string *str) {
  if (aligned(str->len, 16) <= str->size)
    m_string_expand(str);
}

m_string *m_string_concat(m_string *a, m_string *b) {
  m_string *c = m_string_with_capacity(a->len + b->len);

  for (size_t i = 0, s = a->size >> (sizeof(uintptr_t)); i < s; ++i) {
    c->head.__n[i] = a->head.__n[i];
  }

  for (size_t i = 0, s = b->len, h = a->len; i < s; ++i) {
    c->head.__u8[i + h] = b->head.__u8[i];
  }

  return c;
}

// primitive types

typedef struct {
  uint16_t type;
  union {
    m_int     integer;
    m_string *string;
    bool      boolean;
  } entity;
} maysick_any;

enum {
  M_INTEGER,
  M_STRING,
  M_BOOL,
  M_NIL,
} maysick_type;

// type-cast for compiler-generated code
maysick_any m_any_int(m_int i);

maysick_any m_any_int(m_int i) {
  maysick_any a;
  a.type           = M_INTEGER;
  a.entity.integer = i;
  return a;
}

maysick_any m_any_string(m_string *s) {
  maysick_any a;
  a.type          = M_STRING;
  a.entity.string = s;
  return a;
}

maysick_any m_any_bool(bool b) {
  maysick_any a;
  a.type           = M_BOOL;
  a.entity.boolean = b;
  return a;
}

m_string *m_to_string(maysick_any a) {
  m_string *s;

  switch (a.type) {
  case M_STRING:
    return a.entity.string;
    break;
  case M_INTEGER:
    s = m_string_new();
    sprintf(s->head.__u8, "%lld", a.entity.integer);
    return s;
    break;
  case M_BOOL:
    return m_string_from_cstr(a.entity.boolean ? "true" : "false");
    break;
  case M_NIL:
    return m_string_from_cstr("(Nil)");
    break;
  default:
    return m_string_from_cstr("(cast error)");
    break;
  }
}

m_int m_to_integer(maysick_any a) {
  int i;

  switch (a.type) {
  case M_STRING:
    sscanf(a.entity.string->head.__u8, "%d", &i);
    return (m_int)i;
    break;
  case M_INTEGER:
    return a.entity.integer;
    break;
  case M_BOOL:
    return a.entity.boolean;
    break;
  case M_NIL:
    return 0;
    break;
  default:
    return 0;
    break;
  }
}

// prototype of built-in functions

void      _mS__print(m_string *msg);
void      _mS__println(m_string *msg);
m_int     _m_i_random();
m_string *_m_S_getchar();
m_string *_m_S_readline();

m_int     _m_i_slen(m_string *str);
m_int     _mSi_i_char_at(m_string *str, m_int pos);
m_string *_mi_S_char_from(m_int c);
m_string *_mi_S_integer_as_hex(m_int c);

// implementation of built-in functions

void _mS__print(m_string *msg) { printf("%s", msg->head.__u8); }
void _mS__println(m_string *msg) { printf("%s\n", msg->head.__u8); }

m_int _m_i_random() { return (m_int)rand(); }

m_string *_m_S_getchar() {
  m_string *s = m_string_new();
  int       c = getchar();

  if (c == -1) {
    return s; // EOF fallback
  }

  if (c <= 0x7F) {
    s->head.__u8[0] = c;
    s->len          = 1;
  } else { // might be UTF-8
    uint32_t cnt    = __builtin_clz((~c) & 0xFF) - 24;
    s->len          = cnt;
    s->head.__u8[0] = (char)c;
    for (int i = 1; i < cnt; i++) {
      s->head.__u8[i] = getchar();
    }
  }

  return s;
}

m_string *_m_S_readline() {
  m_string *str = m_string_new();
  return str;
}

m_int _m_i_slen(m_string *str) { return (m_int)str->len; }

m_int _mSi_i_char_at(m_string *str, m_int pos) {
  size_t         j = 0;
  unsigned char *s = str->head.__u8;

  for (size_t i = 0; i < pos; i++) {
    char c = s[j];
    if (c <= 0x7F)
      j++;
    else {
      j += __builtin_clz((~c) & 0xFF) - 24;
    }
  }

  unsigned char c   = s[j];
  uint32_t      cnt = __builtin_clz((~c) & 0xFF) - 25;
  uint32_t      ch  = c & (0x3F >> cnt);

  if (c <= 0x7F)
    return (m_int)c;

  for (size_t i = 0; i < cnt; i++) {
    ch = (ch << 6) | (s[++j] & 0x3F);
  }

  return (m_int)ch;
}

m_string *_mi_S_char_from(m_int c) {
  m_string *s = m_string_new();

  if (c <= 0x7F) {
    s->head.__u8[0] = c;
    s->len          = 1;
  }

  return s;
}

m_string *_mi_S_integer_as_hex(m_int c) {
  m_string *s = m_string_new();
  sprintf(s->head.__u8, "%X", c);
  return s;
}

// this symbol will be emitted by maysick compiler
void m_entry();

int main(int argc, const char **argv) {
  // initialize randomizer
  srand((unsigned)time(NULL));
  // jump to the entry point of maysick program.
  m_entry();

  return 0;
}

// -- and the actual program goes --
