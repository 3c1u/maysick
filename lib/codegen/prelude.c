// Auto-generated by maysick compiler

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef __WATCOMC__
#define SJIS_MODE
#endif

typedef int64_t m_int;

enum {
  M_INIT_STRSIZE = 0x100,
};

typedef struct {
  size_t size;
  size_t len;
  char * head;
} m_string;

#define __aligned(n, a) (n & (~a)) + ((n & a) != 0 ? (a + 1) : 0)
#define aligned(n, align) (__aligned((n), (align - 1)))

m_string *m_string_with_capacity(size_t size) {
  m_string *str = calloc(1, sizeof(m_string));

  str->len  = 0;
  str->size = size < M_INIT_STRSIZE ? M_INIT_STRSIZE : aligned(size, 16);
  str->head = calloc(str->size, 1);

  return str;
}

m_string *m_string_new() { return m_string_with_capacity(0); }

m_string *m_string_from_cstr(const char *cstr) {
  size_t    len = strlen(cstr);
  m_string *s   = m_string_with_capacity(len);

  s->len = len;
  memcpy(s->head, cstr, len);

  return s;
}

void m_string_free(m_string *str) {
  free(str->head);
  free(str);
}

void m_string_expand(m_string *str) {
  char *head_new = calloc(str->size << 1, 1);

  memcpy(head_new, str->head, str->len);
  free(str->head);

  str->head = head_new;
  str->size = str->size << 1;
}

void m_string_expand_if_needed(m_string *str) {
  if (aligned(str->len, 16) <= str->size)
    m_string_expand(str);
}

m_string *m_string_concat(m_string *a, m_string *b) {
  m_string *c = m_string_with_capacity(a->len + b->len);

  memcpy(c->head, a->head, a->len);
  memcpy(&c->head[a->len], b->head, b->len);

  c->len = a->len + b->len;

  return c;
}

// primitive types

typedef struct {
  uint16_t type;
  union {
    m_int     integer;
    m_string *string;
    bool      boolean;
  } entity;
} maysick_any;

enum {
  M_INTEGER,
  M_STRING,
  M_BOOL,
  M_NIL,
} maysick_type;

// type-cast for compiler-generated code

// macro for dropping value
#define m_any_nil(a) m_any_nil_()

maysick_any m_any_int(m_int i);
maysick_any m_any_string(m_string *s);
maysick_any m_any_bool(bool b);
maysick_any m_any_nil_();

maysick_any m_any_int(m_int i) {
  maysick_any a;
  a.type           = M_INTEGER;
  a.entity.integer = i;
  return a;
}

maysick_any m_any_string(m_string *s) {
  maysick_any a;
  a.type          = M_STRING;
  a.entity.string = s;
  return a;
}

maysick_any m_any_bool(bool b) {
  maysick_any a;
  a.type           = M_BOOL;
  a.entity.boolean = b;
  return a;
}

maysick_any m_any_nil_() {
  maysick_any a;
  a.type = M_NIL;
  return a;
}

m_string *m_to_string(maysick_any a) {
  m_string *s;

  switch (a.type) {
  case M_STRING:
    return a.entity.string;
    break;
  case M_INTEGER:
    s = m_string_new();
    sprintf(s->head, "%lld", a.entity.integer);
    return s;
    break;
  case M_BOOL:
    return m_string_from_cstr(a.entity.boolean ? "true" : "false");
    break;
  case M_NIL:
    return m_string_from_cstr("(Nil)");
    break;
  default:
    return m_string_from_cstr("(cast error)");
    break;
  }
}

m_int m_to_integer(maysick_any a) {
  int i;

  switch (a.type) {
  case M_STRING:
    sscanf(a.entity.string->head, "%d", &i);
    return (m_int)i;
    break;
  case M_INTEGER:
    return a.entity.integer;
    break;
  case M_BOOL:
    return a.entity.boolean;
    break;
  case M_NIL:
    return 0;
    break;
  default:
    return 0;
    break;
  }
}

// prototype of built-in functions

void      _mS__print(m_string *msg);
void      _mS__println(m_string *msg);
m_int     _m_i_random();
m_string *_m_S_getchar();
m_string *_m_S_readline();

m_int     _m_i_slen(m_string *str);
m_int     _mSi_i_char_at(m_string *str, m_int pos);
m_string *_mi_S_char_from(m_int c);
m_string *_mi_S_integer_as_hex(m_int c);

// implementation of built-in functions

void _mS__print(m_string *msg) { printf("%s", msg->head); }
void _mS__println(m_string *msg) { printf("%s\n", msg->head); }

m_int _m_i_random() { return (m_int)rand(); }

m_string *_m_S_getchar() {
  m_string *s = m_string_new();
  int       c = getchar();
  int       i;

  if (c == -1) {
    return s; // EOF fallback
  }

#ifdef SJIS_MODE
  // Watcom C (which may use Shift_JIS)
  if (c <= 0x7F || (0xA1 <= c && 0xDF <= c)) {
    s->head[0] = c;
    s->len     = 1;
  } else {
    s->head[0] = c;
    s->head[1] = getchar();
    s->len     = 2;
  }
#else
  // gcc or compatible (which uses UTF-8 internally)
  if (c <= 0x7F) {
    s->head[0] = c;
    s->len     = 1;
  } else { // might be UTF-8
    uint32_t cnt = __builtin_clz((~c) & 0xFF) - 24;
    s->len       = cnt;
    s->head[0]   = (char)c;
    for (i = 1; i < cnt; i++) {
      s->head[i] = getchar();
    }
  }
#endif

  return s;
}

m_string *_m_S_readline() {
  m_string *str = m_string_new();
  return str;
}

m_int _m_i_slen(m_string *str) {
  size_t         i = 0, j = 0;
  unsigned char *s = str->head;

  for (i = 0; i < str->len; i++) {
    char c = s[j];
#ifdef SJIS_MODE
    if (c <= 0x7F || (0xA1 <= c && 0xDF <= c)) {
      j++;
    } else {
      j += 2;
    }
#else
    if (c <= 0x7F)
      j++;
    else {
      j += __builtin_clz((~c) & 0xFF) - 24;
    }
#endif
  }

  return j;
}

m_int _mSi_i_char_at(m_string *str, m_int pos) {
  size_t         i = 0, j = 0, cnt, ch;
  unsigned char *s = str->head;
  unsigned char  c;

  for (i = 0; i < pos; i++) {
    char c = s[j];
#ifdef SJIS_MODE
    if (c <= 0x7F || (0xA1 <= c && 0xDF <= c)) {
      j++;
    } else {
      j += 2;
    }
#else
    if (c <= 0x7F)
      j++;
    else {
      j += __builtin_clz((~c) & 0xFF) - 24;
    }
#endif
  }

#ifdef SJIS_MODE
  c = s[j];
  if (c <= 0x7F || (0xA1 <= c && 0xDF <= c)) {
    ch = c;
  } else {
    ch = c | (s[j + 1] << 8);
  }
#else
  c   = s[j];
  cnt = __builtin_clz((~c) & 0xFF) - 25;
  ch  = c & (0x3F >> cnt);

  if (c <= 0x7F)
    return (m_int)c;

  for (i = 0; i < cnt; i++) {
    ch = (ch << 6) | (s[++j] & 0x3F);
  }
#endif

  return (m_int)ch;
}

m_string *_mi_S_char_from(m_int c) {
  m_string *s = m_string_new();
#ifdef SJIS_MODE
  if (c <= 0xFF) {
    s->head[0] = c;
    s->len     = 1;
  } else {
    s->head[0] = c & 0xFF;
    s->head[1] = c >> 8;
    s->len     = 2;
  }
#else
  if (c <= 0x7F) {
    s->head[0] = c;
    s->len     = 1;
  }
#endif

  return s;
}

m_string *_mi_S_integer_as_hex(m_int c) {
  m_string *s = m_string_new();
  sprintf(s->head, "%X", c);
  return s;
}

// this symbol will be emitted by maysick compiler
void m_entry();

int main(int argc, const char **argv) {
  // initialize randomizer
  srand((unsigned)time(NULL));

  // jump to the entry point of maysick program.
  m_entry();

  return 0;
}

// -- and the actual program goes --
