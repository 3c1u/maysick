// Auto-generated by maysick compiler

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef int64_t m_int;

enum {
  M_INIT_STRSIZE = 0x100,
};

typedef struct {
  size_t size;
  size_t len;
  union {
    char *     __u8;
    uintptr_t *__n;
  } head;
} maysick_string;

#define __aligned(n, a) (n & (~a)) + (n & a != 0 ? a : 0)
#define aligned(n, align) (__aligned((n), (align - 1)))

maysick_string *m_string_with_capacity(size_t size) {
  maysick_string *str = calloc(1, sizeof(maysick_string));

  str->len       = 0;
  str->size      = size < M_INIT_STRSIZE ? M_INIT_STRSIZE : aligned(size, 16);
  str->head.__u8 = calloc(sizeof(uintptr_t), str->size >> sizeof(uintptr_t));

  return str;
}

maysick_string *m_string_new() { return m_string_with_capacity(0); }

maysick_string *m_string_from_cstr(const char *cstr) {
  size_t          len = strlen(cstr);
  maysick_string *s   = m_string_with_capacity(len);

  for (size_t i = 0; i < len; i++) {
    s->head.__u8[i] = cstr[i];
  }

  return s;
}

void m_string_free(maysick_string *str) { free(str->head.__u8); }

void m_string_expand(maysick_string *str) {
  uintptr_t *head_new =
      calloc(sizeof(uintptr_t), str->size >> (sizeof(uintptr_t) >> 1));

  for (size_t i = 0, s = str->size >> (sizeof(uintptr_t)); i < s; ++i) {
    head_new[i] = str->head.__n[i];
  }

  free(str->head.__u8);

  str->head.__n = head_new;
  str->size     = str->size << 1;
}

void m_string_expand_if_needed(maysick_string *str) {
  if (aligned(str->len, 16) <= str->size)
    m_string_expand(str);
}

maysick_string *m_string_concat(maysick_string *a, maysick_string *b) {
  maysick_string *c = m_string_with_capacity(a->len + b->len);

  for (size_t i = 0, s = a->size >> (sizeof(uintptr_t)); i < s; ++i) {
    c->head.__n[i] = a->head.__n[i];
  }

  for (size_t i = 0, s = b->len, h = a->len; i < s; ++i) {
    c->head.__u8[i + h] = b->head.__u8[i];
  }

  return c;
}

// primitive types

typedef struct {
  uint16_t type;
  union {
    m_int           integer;
    maysick_string *string;
    bool            boolean;
  } entity;
} maysick_any;

enum {
  M_INTEGER,
  M_STRING,
  M_BOOL,
  M_NIL,
} maysick_type;

// type-cast for compiler-generated code
maysick_any m_any_int(m_int i);

maysick_any m_any_int(m_int i) {
  maysick_any a;
  a.type           = M_INTEGER;
  a.entity.integer = i;
  return a;
}

maysick_any m_any_string(maysick_string *s) {
  maysick_any a;
  a.type          = M_STRING;
  a.entity.string = s;
  return a;
}

maysick_any m_any_bool(bool b) {
  maysick_any a;
  a.type           = M_BOOL;
  a.entity.boolean = b;
  return a;
}

maysick_string *m_to_string(maysick_any a) {
  maysick_string *s;

  switch (a.type) {
  case M_STRING:
    return a.entity.string;
    break;
  case M_INTEGER:
    s = m_string_new();
    sprintf(s->head.__u8, "%d", a.entity.integer);
    return s;
    break;
  case M_BOOL:
    return m_string_from_cstr(a.entity.boolean ? "true" : "false");
    break;
  case M_NIL:
    return m_string_from_cstr("(Nil)");
    break;
  default:
    return m_string_from_cstr("(cast error)");
    break;
  }
}

m_int m_to_integer(maysick_any a) {
  int i;

  switch (a.type) {
  case M_STRING:
    sscanf(a.entity.string->head.__u8, "%d", &i);
    return (m_int)i;
    break;
  case M_INTEGER:
    return a.entity.integer;
    break;
  case M_BOOL:
    return a.entity.boolean;
    break;
  case M_NIL:
    return 0;
    break;
  default:
    return 0;
    break;
  }
}

// prototype of built-in functions

void            _mS__print(maysick_string *msg);
void            _mS__println(maysick_string *msg);
m_int           _m_i_random();
m_int           _m_i_getchar();
maysick_string *_m_S_readline();

m_int _m_i_slen(maysick_string *str);
m_int _mSi_i_char_at(maysick_string *str, m_int pos);

// implementation of built-in functions

void _mS__print(maysick_string *msg) { printf("%s", msg->head.__u8); }
void _mS__println(maysick_string *msg) { printf("%s\n", msg->head.__u8); }

m_int _m_i_random() { return (m_int)rand(); }
m_int _m_i_getchar() { return getchar(); }

maysick_string *_m_S_readline() {
  maysick_string *str = m_string_new();
  return str;
}

// this symbol will be emitted by maysick compiler
void m_entry();

int main(int argc, const char **argv) {
  // initialize randomizer
  srand((unsigned)time(NULL));
  // jump to the entry point of maysick program.
  m_entry();

  return 0;
}

// -- and the actual program goes --
